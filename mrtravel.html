<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SE London Presenter Dashboard</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2em;
      max-width: 900px;
      margin: auto;
      background: #fafafa;
    }
    h1, h2 { text-align: center; }
    .section { margin-bottom: 2em; }
    .item { background: white; padding: 1em; margin-bottom: .8em; border-left: 6px solid; border-radius: 5px; }
    /* Existing severity colors */
    .high { border-color: #e53935; } /* Red */
    .medium { border-color: #fb8c00; } /* Orange */
    .low { border-color: #43a047; } /* Green */

    /* New style for tube lines to ensure consistent spacing */
    .tube-line-item {
        display: flex;
        align-items: center; /* Vertically center content */
    }
    .tube-line-item strong {
        margin-right: 0.5em;
    }
    /* Style for TfL traffic and roadworks - can be merged with .item if desired */
    .tfl-item { /* A common class for all TfL road-related items */
      background: white;
      padding: 1em;
      margin-bottom: .8em;
      border-left: 6px solid;
      border-radius: 5px;
    }
    .tfl-item.high { border-color: #e53935; }
    .tfl-item.medium { border-color: #fb8c00; }
    .tfl-item.low { border-color: #43a047; }
    /* Specific styling for TfL roadworks */
    .tfl-roadwork-item {
        border-color: #5d4037; /* A distinct brown for roadworks */
    }
    .tfl-roadwork-item.high { border-color: #e53935; } /* Still use red for high severity */
  </style>
</head>
<body>
  <h1>SE London Presenter Dashboard</h1>

  <div class="section" id="traffic">
    <h2>ðŸš¦ Traffic Hotspots (All Incidents)</h2>
    <h3>From TomTom</h3>
    <div id="incidents">Loading TomTom trafficâ€¦</div>
    <h3>From TfL Road Network</h3>
    <div id="tfl-traffic-incidents" style="margin-top: 1.5em;">Loading TfL trafficâ€¦</div>
  </div>

  <div class="section" id="roadworks-today">
    <h2>ðŸ›  Today's Roadworks</h2>
    <h3>From TomTom</h3>
    <div id="roadworks">Loading TomTom roadworksâ€¦</div>
    <h3>From TfL Road Network</h3>
    <div id="tfl-roadworks-incidents" style="margin-top: 1.5em;">Loading TfL roadworksâ€¦</div>
  </div>

  <div class="section" id="transport">
    <h2>ðŸš‡ Public Transport Status</h2>
    <div>
      <h3>Tube Status</h3>
      <div id="tube-status">Loading Tube statusâ€¦</div>
    </div>
    <div>
      <h3>River Bus</h3>
      <div id="river">Loading River Busâ€¦</div>
    </div>
    <div>
      <h3>Woolwich Ferry</h3>
      <div id="ferry">Loading Woolwich Ferryâ€¦</div>
    </div>
  </div>

  <script>
    const TOMTOM_KEY = "ZKntlBjAvEOBSRtfMsEdbo31b6UcmJHJ";
    const TFL_KEY = "044bd54cfdc94f03ba10314d52eb59fe";

    // Refresh interval for all data fetches (5 minutes)
    const REFRESH_INTERVAL_MS = 5 * 60 * 1000;

    // Coordinates for Southeast London (tlLat, tlLon, brLat, brLon)
    const bbox = {
      tlLat: 51.51, tlLon: -0.12,
      brLat: 51.30, brLon: 0.25
    };

    // Helper to check if coordinates are within the SE London bbox
    function isWithinBbox(lat, lon) {
      return lat <= bbox.tlLat && lat >= bbox.brLat &&
             lon >= bbox.tlLon && lon <= bbox.brLon;
    }

    // --- TomTom Traffic Functions (unchanged) ---
    async function fetchTraffic() {
      const url = `https://api.tomtom.com/traffic/services/5/incidentDetails?bbox=${bbox.tlLat},${bbox.tlLon},${bbox.brLat},${bbox.brLon}&fields=roadNumbers,events&language=en-GB&key=${TOMTOM_KEY}`;
      try {
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error(`TomTom API responded with status: ${resp.status} ${resp.statusText}`);
        }
        const data = await resp.json();
        return data.incidents || [];
      } catch (error) {
        console.error("Error fetching TomTom traffic data:", error);
        document.getElementById("incidents").textContent = "Error loading TomTom traffic incidents.";
        document.getElementById("roadworks").textContent = "Error loading TomTom roadworks.";
        return [];
      }
    }

    function isEventToday(event) {
      if (!event || !event.startTime || !event.endTime) return false;
      const now = new Date();
      const start = new Date(event.startTime);
      const end = new Date(event.endTime);
      return start <= now && now <= end && start.toDateString() === now.toDateString();
    }

    function renderTraffic(list) {
      const container = document.getElementById("incidents");
      container.innerHTML = "";
      if (!list.length) return container.innerHTML = "<p>No TomTom traffic incidents reported.</p>";

      list.sort((a, b) => b.severity - a.severity);

      list.forEach(i => {
        const sev = i.severity >= 4 ? "high" : i.severity >= 2 ? "medium" : "low";
        const emoji = sev === "high" ? "ðŸ”´" : sev === "medium" ? "ðŸŸ " : "ðŸŸ¢";

        const type = i.type?.replaceAll("_", " ").toLowerCase() || "incident";
        const roads = i.roadNumbers?.join(", ") || "Unnamed road";
        const desc = i.events?.[0]?.description || "No description available";

        const d = document.createElement("div");
        d.className = `item ${sev}`;
        d.innerHTML = `
          <strong>${emoji} ${roads}</strong> â€“ 
          <em>${type}</em><br>
          ${desc} 
          <br><small>Severity: ${i.severity}</small>
        `;
        container.appendChild(d);
      });
    }

    function renderRoadworksToday(list) {
      const container = document.getElementById("roadworks");
      container.innerHTML = "";
      if (!list.length) {
        container.innerHTML = "<p>No TomTom roadworks reported for today.</p>";
        return;
      }

      const roadworksTypes = ["ROAD_WORK", "CONSTRUCTION", "MAINTENANCE"];
      const todayRoadworks = list.filter(i =>
        roadworksTypes.includes(i.type) &&
        i.events?.some(isEventToday)
      );

      if (!todayRoadworks.length) {
        container.innerHTML = "<p>No TomTom roadworks reported for today.</p>";
        return;
      }

      todayRoadworks.sort((a, b) => b.severity - a.severity);

      todayRoadworks.forEach(i => {
        const sev = i.severity >= 4 ? "high" : i.severity >= 2 ? "medium" : "low";
        const emoji = sev === "high" ? "ðŸ”´" : sev === "medium" ? "ðŸŸ " : "ðŸŸ¢";

        const roads = i.roadNumbers?.join(", ") || "Unnamed road";
        const desc = i.events?.[0]?.description || "No description available";

        const d = document.createElement("div");
        d.className = `item ${sev}`;
        d.innerHTML = `
          <strong>${emoji} ${roads}</strong> â€“ 
          <em>roadwork</em><br>
          ${desc} 
          <br><small>Severity: ${i.severity}</small>
        `;
        container.appendChild(d);
      });
    }

    // --- NEW/MODIFIED: TfL Road Network Functions ---
    // This function now fetches all disruptions and categorizes them
    async function fetchTfLRoadDisruptions() {
      const url = `https://api.tfl.gov.uk/Road/All/Disruption?app_key=${TFL_KEY}`;
      let allTfLDisruptions = [];
      let tflTrafficIncidents = [];
      let tflRoadworksIncidents = [];

      try {
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error(`TfL Road Disruption API responded with status: ${resp.status} ${resp.statusText}`);
        }
        const data = await resp.json();
        allTfLDisruptions = data.roadDisruptions || [];

        // Filter by bbox for South East London and categorize
        allTfLDisruptions.forEach(incident => {
          if (incident.point && !isNaN(parseFloat(incident.point.split(',')[0])) && !isNaN(parseFloat(incident.point.split(',')[1]))) {
            const [lat, lon] = incident.point.split(',').map(Number);
            if (isWithinBbox(lat, lon)) {
              // Categorize based on 'category' field
              const isRoadwork = incident.category?.toLowerCase().includes('roadworks') || incident.category?.toLowerCase().includes('plannedworks') || incident.category?.toLowerCase().includes('works');

              if (isRoadwork) {
                tflRoadworksIncidents.push(incident);
              } else {
                // All other disruptions (accidents, events etc.) go to general traffic
                tflTrafficIncidents.push(incident);
              }
            }
          }
        });
        
        return { tflTrafficIncidents, tflRoadworksIncidents };
      } catch (error) {
        console.error("Error fetching TfL road disruptions data:", error);
        document.getElementById("tfl-traffic-incidents").textContent = "Error loading TfL traffic incidents.";
        document.getElementById("tfl-roadworks-incidents").textContent = "Error loading TfL roadworks.";
        return { tflTrafficIncidents: [], tflRoadworksIncidents: [] };
      }
    }

    // New render function for TfL general traffic incidents
    function renderTfLTraffic(list) {
        const container = document.getElementById("tfl-traffic-incidents");
        container.innerHTML = "";
        if (!list.length) {
            return container.innerHTML = "<p>No TfL traffic incidents reported for SE London.</p>";
        }

        const severityOrder = { "Serious": 1, "Major": 2, "Minor": 3, "Moderate": 4, "Normal": 5, "Good": 6 };
        list.sort((a, b) => {
            const aSev = severityOrder[a.severity] || 99;
            const bSev = severityOrder[b.severity] || 99;
            return aSev - bSev;
        });

        list.forEach(incident => {
            const description = incident.comments || incident.location || "No description available";
            const currentStatus = incident.currentStatus || "Status unknown";
            const category = incident.category || "Incident";
            const roadNames = incident.roadName || "Unnamed road";

            let sevClass = "low"; 
            let emoji = "ðŸ”µ"; 
            if (incident.severity === "Serious") {
                sevClass = "high";
                emoji = "ðŸš¨";
            } else if (incident.severity === "Major" || incident.severity === "Minor") {
                sevClass = "medium";
                emoji = "ðŸ”¶";
            }

            const d = document.createElement("div");
            d.className = `item tfl-item ${sevClass}`; 
            d.innerHTML = `
                <strong>${emoji} ${roadNames}</strong> â€“ 
                <em>${category} (${currentStatus})</em><br>
                ${description}
                <br><small>Severity: ${incident.severity || 'Unknown'}</small>
            `;
            container.appendChild(d);
        });
    }

    // New render function for TfL Roadworks
    function renderTfLRoadworks(list) {
        const container = document.getElementById("tfl-roadworks-incidents");
        container.innerHTML = "";
        if (!list.length) {
            return container.innerHTML = "<p>No TfL roadworks reported for SE London.</p>";
        }

        const severityOrder = { "Serious": 1, "Major": 2, "Minor": 3, "Moderate": 4, "Normal": 5, "Good": 6 };
        list.sort((a, b) => {
            const aSev = severityOrder[a.severity] || 99;
            const bSev = severityOrder[b.severity] || 99;
            return aSev - bSev;
        });

        list.forEach(incident => {
            const description = incident.comments || incident.location || "No description available";
            const currentStatus = incident.currentStatus || "Status unknown";
            const roadNames = incident.roadName || "Unnamed road";
            // Roadworks emoji
            let emoji = "ðŸš§"; 

            let sevClass = "low"; 
            if (incident.severity === "Serious") {
                sevClass = "high";
            } else if (incident.severity === "Major" || incident.severity === "Minor") {
                sevClass = "medium";
            }

            const d = document.createElement("div");
            d.className = `item tfl-item tfl-roadwork-item ${sevClass}`; // Use tfl-roadwork-item for distinct styling
            d.innerHTML = `
                <strong>${emoji} ${roadNames}</strong> â€“ 
                <em>Roadwork (${currentStatus})</em><br>
                ${description}
                <br><small>Severity: ${incident.severity || 'Unknown'}</small>
            `;
            container.appendChild(d);
        });
    }

    // --- Unified Traffic Update ---
    async function updateTraffic() {
      // TomTom Traffic
      const tomtomIncidents = await fetchTraffic();
      renderTraffic(tomtomIncidents);
      renderRoadworksToday(tomtomIncidents); // Roadworks still from TomTom

      // TfL Road Disruptions (now categorized)
      const { tflTrafficIncidents, tflRoadworksIncidents } = await fetchTfLRoadDisruptions();
      renderTfLTraffic(tflTrafficIncidents);
      renderTfLRoadworks(tflRoadworksIncidents); // Render TfL specific roadworks

      setTimeout(updateTraffic, REFRESH_INTERVAL_MS);
    }
    updateTraffic(); 

    // --- TfL Public Transport Functions (unchanged from last update) ---
    async function fetchTfLStatus(lines) {
      const url = `https://api.tfl.gov.uk/Line/${lines}/Status?app_key=${TFL_KEY}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`TfL API error: ${res.status} ${res.statusText}`);
      return await res.json();
    }

    async function fetchAndRenderTubeStatus() {
      const container = document.getElementById("tube-status");
      container.innerHTML = ''; 
      try {
        const url = `https://api.tfl.gov.uk/Line/Mode/tube/Status?app_key=${TFL_KEY}`;
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`TfL API error: ${res.status} ${res.statusText}`);
        }
        const data = await res.json();

        if (!Array.isArray(data) || data.length === 0) {
          container.textContent = "No Tube status data available.";
          return;
        }

        data.sort((a, b) => {
          const aSeverity = a.lineStatuses?.[0]?.statusSeverity;
          const bSeverity = b.lineStatuses?.[0]?.statusSeverity;

          const aHasIssue = aSeverity !== 10; 
          const bHasIssue = bSeverity !== 10;

          if (aHasIssue && !bHasIssue) return -1; 
          if (!aHasIssue && bHasIssue) return 1;  

          if (aHasIssue && bHasIssue) {
            return aSeverity - bSeverity;
          } else { 
            return a.name.localeCompare(b.name);
          }
        });

        data.forEach(line => {
          const name = line.name || "Unknown line";
          const statusObj = line.lineStatuses?.[0];
          const status = statusObj?.statusSeverityDescription || "Status unknown";
          const reason = statusObj?.reason || "";
          const severity = statusObj?.statusSeverity;

          let sevClass = "low"; 
          let emoji = "ðŸŸ¢"; 

          if (severity !== undefined) {
            if (severity === 10) { 
              sevClass = "low";
              emoji = "ðŸŸ¢";
            } else if (severity === 0) { 
              sevClass = "high";
              emoji = "ðŸ”´";
            } else { 
              sevClass = "medium";
              emoji = "ðŸŸ ";
            }
          }
          
          const d = document.createElement("div");
          d.className = `item ${sevClass} tube-line-item`; 
          d.innerHTML = `
            <strong>${emoji} ${name}:</strong> ${status}${reason ? " â€“ " + reason : ""}
          `;
          container.appendChild(d);
        });

      } catch (err) {
        container.textContent = "Error fetching Tube status: " + err.message;
        console.error(err);
      }
    }

    async function fetchAndRenderOtherStatus(containerId, lines, label) {
      const container = document.getElementById(containerId);
      try {
        const data = await fetchTfLStatus(lines);
        if (!Array.isArray(data) || data.length === 0) {
          container.textContent = `No ${label} status data available.`;
          return;
        }

        const messages = data.map(line => {
          const name = line.name || label;
          const status = line.lineStatuses?.[0]?.statusSeverityDescription || "Unknown";
          const reason = line.lineStatuses?.[0]?.reason || "";
          const severity = line.lineStatuses?.[0]?.statusSeverity;
          let emoji = "ðŸš‰"; 

          if (severity !== undefined) {
             if (severity === 0) { 
               emoji = "ðŸ”´";
             } else if (severity !== 10) { 
               emoji = "ðŸŸ ";
             }
          }

          return `${emoji} ${name}: ${status}${reason ? " â€“ " + reason : ""}`;
        });

        container.innerHTML = "<ul>" + messages.map(m => `<li>${m}</li>`).join("") + "</ul>";
      } catch (err) {
        container.textContent = `Error fetching ${label} status: ` + err.message;
        console.error(err);
      }
    }

    async function updateTfL() {
      await fetchAndRenderTubeStatus();
      await fetchAndRenderOtherStatus("river", "rb1,rb6", "River Bus");
      await fetchAndRenderOtherStatus("ferry", "woolwich-ferry", "Woolwich Ferry");
      setTimeout(updateTfL, REFRESH_INTERVAL_MS);
    }
    updateTfL();
  </script>
</body>
</html>
