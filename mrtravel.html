<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SE London Presenter Dashboard</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2em;
      max-width: 900px;
      margin: auto;
      background: #fafafa;
    }
    h1, h2, h3 { text-align: center; } /* Center all headings */
    .section { margin-bottom: 2em; }
    .item { background: white; padding: 1em; margin-bottom: .8em; border-left: 6px solid; border-radius: 5px; }
    /* Existing severity colors */
    .high { border-color: #e53935; } /* Red */
    .medium { border-color: #fb8c00; } /* Orange */
    .low { border-color: #43a047; } /* Green */

    /* New style for tube lines to ensure consistent spacing */
    .tube-line-item {
        display: flex;
        align-items: center; /* Vertically center content */
    }
    .tube-line-item strong {
        margin-right: 0.5em;
    }
    /* Style for TfL traffic and roadworks */
    .tfl-item {
      background: white;
      padding: 1em;
      margin-bottom: .8em;
      border-left: 6px solid;
      border-radius: 5px;
    }
    .tfl-item.high { border-color: #e53935; }
    .tfl-item.medium { border-color: #fb8c00; }
    .tfl-item.low { border-color: #43a047; }
    /* Specific styling for TfL roadworks */
    .tfl-roadwork-item {
        border-color: #5d4037; /* A distinct brown for roadworks */
    }
    .tfl-roadwork-item.high { border-color: #e53935; } /* Still use red for high severity */

    /* Weather Forecast Styling */
    #weather-forecast {
        background: #e0f2f7; /* Light blue background */
        padding: 1.5em;
        margin-bottom: 2em;
        border-radius: 8px;
        text-align: center;
        font-size: 1.1em;
        color: #01579b; /* Darker blue text */
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #weather-forecast strong {
        font-size: 1.3em;
        color: #01579b;
    }
    #weather-forecast small {
        display: block;
        margin-top: 0.5em;
        color: #0277bd;
    }
  </style>
</head>
<body>
  <div id="weather-forecast">Loading local weather forecast...</div>

  <h1>SE London Presenter Dashboard</h1>

  <div class="section" id="traffic">
    <h2>üö¶ Traffic Hotspots (All Incidents)</h2>
    <h3>From TomTom</h3>
    <div id="incidents">Loading TomTom traffic‚Ä¶</div>
    <h3>From TfL Road Network</h3>
    <div id="tfl-traffic-incidents" style="margin-top: 1.5em;">Loading TfL traffic‚Ä¶</div>
  </div>

  <div class="section" id="roadworks-today">
    <h2>üõ† Today's Roadworks</h2>
    <h3>From TomTom</h3>
    <div id="roadworks">Loading TomTom roadworks‚Ä¶</div>
    <h3>From TfL Road Network</h3>
    <div id="tfl-roadworks-incidents" style="margin-top: 1.5em;">Loading TfL roadworks‚Ä¶</div>
  </div>

  <div class="section" id="transport">
    <h2>üöá Public Transport Status</h2>
    <div>
      <h3>Tube Status</h3>
      <div id="tube-status">Loading Tube status‚Ä¶</div>
    </div>
    <div>
      <h3>River Bus</h3>
      <div id="river">Loading River Bus‚Ä¶</div>
    </div>
    <div>
      <h3>Woolwich Ferry</h3>
      <div id="ferry">Loading Woolwich Ferry‚Ä¶</div>
    </div>
  </div>

  <div class="section" id="rail-delays">
      <h2>üöÜ National Rail Delays (Southeastern & Thameslink)</h2>
      <div id="national-rail-delays">Loading National Rail delays...</div>
  </div>

  <script>
    const TOMTOM_KEY = "ZKntlBjAvEOBSRtfMsEdbo31b6UcmJHJ";
    const TFL_KEY = "044bd54cfdc94f03ba10314d52eb59fe";
    const OPENWEATHER_KEY = "c43b3437c0f093ed56bdc93a115e26a2"; 

    // *** IMPORTANT: You MUST set up a backend proxy for National Rail Data ***
    // This URL will point to YOUR custom API endpoint on your server
    const NATIONAL_RAIL_API_PROXY_URL = "YOUR_NATIONAL_RAIL_API_PROXY_URL"; // Example: "https://yourserver.com/api/national-rail-delays"

    // Refresh interval for most data fetches (5 minutes)
    const REFRESH_INTERVAL_MS = 5 * 60 * 1000;
    // Weather refresh interval (2 hours)
    const WEATHER_REFRESH_INTERVAL_MS = 2 * 60 * 60 * 1000; 
    // National Rail refresh interval (e.g., every 2 minutes, as it's very live)
    const RAIL_REFRESH_INTERVAL_MS = 2 * 60 * 1000;

    // Coordinates for Southeast London (tlLat, tlLon, brLat, brLon)
    const bbox = {
      tlLat: 51.51, tlLon: -0.12,
      brLat: 51.30, brLon: 0.25
    };
    // Central point for weather forecast (e.g., Greenwich)
    const WEATHER_LAT = 51.48;
    const WEATHER_LON = 0.0;

    // List of relevant SE London stations (CRS codes) for National Rail
    const SE_LONDON_RAIL_STATIONS = [
      "LBG", // London Bridge
      "CHX", // Charing Cross
      "WAE", // Waterloo East
      "LEW", // Lewisham
      "GRN", // Greenwich
      "DFD", // Dartford
      "BMS", // Bromley South
      "ORP", // Orpington
      "ECR", // East Croydon (major hub, many SE services)
      "VIC"  // London Victoria (major terminal for Southeastern)
      // Add more stations as needed, e.g., Abbey Wood (ABW), Woolwich Arsenal (WWA) etc.
    ];

    // TOC (Train Operating Company) codes for filtering
    const TARGET_TOC_CODES = ["SE", "TL"]; // Southeastern (SE), Thameslink (TL)

    // Helper to check if coordinates are within the SE London bbox
    function isWithinBbox(lat, lon) {
      return lat <= bbox.tlLat && lat >= bbox.brLat &&
             lon >= bbox.tlLon && lon <= bbox.brLon;
    }

    // --- Weather Forecast Functions ---
    async function fetchWeather() {
      const url = `https://api.openweathermap.org/data/2.5/forecast?lat=${WEATHER_LAT}&lon=${WEATHER_LON}&units=metric&appid=${OPENWEATHER_KEY}`;
      const container = document.getElementById("weather-forecast");

      try {
        const resp = await fetch(url);
        if (!resp.ok) {
          let errorText = await resp.text();
          try {
            const errorJson = JSON.parse(errorText);
            errorText = errorJson.message || errorText;
          } catch (e) { /* Not JSON */ }
          throw new Error(`OpenWeatherMap API responded with status: ${resp.status} ${resp.statusText}. Message: ${errorText}`);
        }
        const data = await resp.json();
        return data;
      } catch (error) {
        console.error("Error fetching weather data:", error);
        container.textContent = `Error loading weather: ${error.message}. Please check your API key and network connection.`;
        return null; 
      }
    }

    function renderWeather(weatherData) {
        const container = document.getElementById("weather-forecast");
        if (!weatherData) {
            return; 
        }

        const forecastList = weatherData.list;
        const city = weatherData.city.name || "Southeast London"; 

        if (!forecastList || forecastList.length === 0) {
            container.textContent = "Weather forecast data incomplete. Please try again.";
            return;
        }

        const now = new Date();
        const currentHour = now.getHours();

        const currentWeather = forecastList[0]; 
        
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()); 
        const tomorrow = new Date(today);
        tomorrow.setDate(today.getDate() + 1); 

        let todayMinTemp = Infinity;
        let todayMaxTemp = -Infinity;
        let tomorrowMinTemp = Infinity;
        let tomorrowMaxTemp = -Infinity;
        let tomorrowDescription = "unclear skies"; 

        let isTomorrowSet = false;

        forecastList.forEach(item => {
            const itemDate = new Date(item.dt * 1000); 
            const itemDay = new Date(itemDate.getFullYear(), itemDate.getMonth(), itemDate.getDate());

            if (itemDay.getTime() === today.getTime()) { 
                todayMinTemp = Math.min(todayMinTemp, item.main.temp_min);
                todayMaxTemp = Math.max(todayMaxTemp, item.main.temp_max);
            } else if (itemDay.getTime() === tomorrow.getTime()) { 
                tomorrowMinTemp = Math.min(tomorrowMinTemp, item.main.temp_min);
                tomorrowMaxTemp = Math.max(tomorrowMaxTemp, item.main.temp_max);
                if (!isTomorrowSet) { // Get a representative description for tomorrow (e.g., from an early forecast)
                    tomorrowDescription = item.weather[0].description;
                    isTomorrowSet = true; 
                }
            }
        });
        
        if (todayMinTemp === Infinity) todayMinTemp = currentWeather.main.temp_min;
        if (todayMaxTemp === -Infinity) todayMaxTemp = currentWeather.main.temp_max;
        if (tomorrowMinTemp === Infinity) tomorrowMinTemp = todayMinTemp; 
        if (tomorrowMaxTemp === -Infinity) tomorrowMaxTemp = todayMaxTemp; 

        const currentDescription = currentWeather.weather[0].description;
        const currentTemp = Math.round(currentWeather.main.temp);
        const feelsLike = Math.round(currentWeather.main.feels_like);
        const roundedTodayHigh = Math.round(todayMaxTemp);
        const roundedTodayLow = Math.round(todayMinTemp);
        const roundedTomorrowHigh = Math.round(tomorrowMaxTemp);
        const roundedTomorrowLow = Math.round(tomorrowMinTemp);


        let greeting = "Hello";
        let detailedForecast = "";

        if (currentHour >= 5 && currentHour < 12) { 
            greeting = "Good morning";
            detailedForecast = `Currently in ${city}, it's ${currentDescription} at ${currentTemp}¬∞C, feeling like ${feelsLike}¬∞C. For today, expect a high of ${roundedTodayHigh}¬∞C and a low of ${roundedTodayLow}¬∞C.`;
        } else if (currentHour >= 12 && currentHour < 18) { 
            greeting = "Good afternoon";
            detailedForecast = `The weather in ${city} is currently ${currentDescription} at ${currentTemp}¬∞C, feeling like ${feelsLike}¬∞C. Temperatures will reach around ${roundedTodayHigh}¬∞C this afternoon.`;
            
            let tonightLow = todayMinTemp; 
            for(let i=1; i < forecastList.length; i++) { 
                const item = forecastList[i];
                const itemDate = new Date(item.dt * 1000);
                const itemDay = new Date(itemDate.getFullYear(), itemDate.getMonth(), itemDate.getDate());
                if (itemDay.getTime() === today.getTime() && itemDate.getHours() >= currentHour) {
                    tonightLow = Math.min(tonightLow, item.main.temp_min);
                } else if (itemDay.getTime() > today.getTime()) {
                    break;
                }
            }
            tonightLow = Math.round(tonightLow);
            detailedForecast += ` Tonight, the low will be around ${tonightLow}¬∞C.`;

        } else if (currentHour >= 18 && currentHour < 22) { 
            greeting = "Good evening";
            detailedForecast = `It's currently ${currentDescription} in ${city} at ${currentTemp}¬∞C, feeling like ${feelsLike}¬∞C.`;
            
            let overnightLow = todayMinTemp; 
            for(let i=1; i < forecastList.length; i++) {
                const item = forecastList[i];
                const itemDate = new Date(item.dt * 1000);
                const itemDay = new Date(itemDate.getFullYear(), itemDate.getMonth(), itemDate.getDate());
                if (itemDay.getTime() === today.getTime() && itemDate.getHours() >= currentHour) {
                    overnightLow = Math.min(overnightLow, item.main.temp_min);
                } else if (itemDay.getTime() > today.getTime()) {
                    break;
                }
            }
            overnightLow = Math.round(overnightLow);
            detailedForecast += ` Overnight, temperatures are set to drop to around ${overnightLow}¬∞C. Looking ahead to tomorrow, expect a high of ${roundedTomorrowHigh}¬∞C with ${tomorrowDescription}.`;

        } else { 
            greeting = "Good night";
            detailedForecast = `The current temperature in ${city} is ${currentTemp}¬∞C, feeling like ${feelsLike}¬∞C, with ${currentDescription}.`;
            
            let overnightLow = todayMinTemp; 
            for(let i=1; i < forecastList.length; i++) {
                const item = forecastList[i];
                const itemDate = new Date(item.dt * 1000);
                const itemDay = new Date(itemDate.getFullYear(), itemDate.getMonth(), itemDate.getDate());
                if (itemDay.getTime() === today.getTime() && itemDate.getHours() >= currentHour) {
                    overnightLow = Math.min(overnightLow, item.main.temp_min);
                } else if (itemDay.getTime() > today.getTime()) {
                    break;
                }
            }
            overnightLow = Math.round(overnightLow);
            detailedForecast += ` Overnight, temperatures will fall to about ${overnightLow}¬∞C. Looking ahead to tomorrow, expect a high of ${roundedTomorrowHigh}¬∞C and a low of ${roundedTomorrowLow}¬∞C, with ${tomorrowDescription}.`;
        }

        container.innerHTML = `<strong>${greeting}!</strong> ${detailedForecast}`;
    }

    // --- TomTom Traffic Functions ---
    async function fetchTraffic() {
      const url = `https://api.tomtom.com/traffic/services/5/incidentDetails?bbox=${bbox.tlLat},${bbox.tlLon},${bbox.brLat},${bbox.brLon}&fields=roadNumbers,events&language=en-GB&key=${TOMTOM_KEY}`;
      try {
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error(`TomTom API responded with status: ${resp.status} ${resp.statusText}`);
        }
        const data = await resp.json();
        return data.incidents || [];
      } catch (error) {
        console.error("Error fetching TomTom traffic data:", error);
        document.getElementById("incidents").textContent = "Error loading TomTom traffic incidents.";
        document.getElementById("roadworks").textContent = "Error loading TomTom roadworks.";
        return [];
      }
    }

    function isEventToday(event) {
      if (!event || !event.startTime || !event.endTime) return false;
      const now = new Date();
      const start = new Date(event.startTime);
      const end = new Date(event.endTime);
      return start <= now && now <= end && start.toDateString() === now.toDateString();
    }

    function renderTraffic(list) {
      const container = document.getElementById("incidents");
      container.innerHTML = "";
      if (!list.length) return container.innerHTML = "<p>No TomTom traffic incidents reported.</p>";

      list.sort((a, b) => b.severity - a.severity);

      list.forEach(i => {
        const sev = i.severity >= 4 ? "high" : i.severity >= 2 ? "medium" : "low";
        const emoji = sev === "high" ? "üî¥" : sev === "medium" ? "üü†" : "üü¢";

        const type = i.type?.replaceAll("_", " ").toLowerCase() || "incident";
        const roads = i.roadNumbers?.join(", ") || "Unnamed road";
        const desc = i.events?.[0]?.description || "No description available";

        const d = document.createElement("div");
        d.className = `item ${sev}`;
        d.innerHTML = `
          <strong>${emoji} ${roads}</strong> ‚Äì 
          <em>${type}</em><br>
          ${desc} 
          <br><small>Severity: ${i.severity}</small>
        `;
        container.appendChild(d);
      });
    }

    function renderRoadworksToday(list) {
      const container = document.getElementById("roadworks");
      container.innerHTML = "";
      if (!list.length) {
        container.innerHTML = "<p>No TomTom roadworks reported for today.</p>";
        return;
      }

      const roadworksTypes = ["ROAD_WORK", "CONSTRUCTION", "MAINTENANCE"];
      const todayRoadworks = list.filter(i =>
        roadworksTypes.includes(i.type) &&
        i.events?.some(isEventToday)
      );

      if (!todayRoadworks.length) {
        container.innerHTML = "<p>No TomTom roadworks reported for today.</p>";
        return;
      }

      todayRoadworks.sort((a, b) => b.severity - a.severity);

      todayRoadworks.forEach(i => {
        const sev = i.severity >= 4 ? "high" : i.severity >= 2 ? "medium" : "low";
        const emoji = sev === "high" ? "üî¥" : sev === "medium" ? "üü†" : "üü¢";

        const roads = i.roadNumbers?.join(", ") || "Unnamed road";
        const desc = i.events?.[0]?.description || "No description available";

        const d = document.createElement("div");
        d.className = `item ${sev}`;
        d.innerHTML = `
          <strong>${emoji} ${roads}</strong> ‚Äì 
          <em>roadwork</em><br>
          ${desc} 
          <br><small>Severity: ${i.severity}</small>
        `;
        container.appendChild(d);
      });
    }

    // --- TfL Road Network Functions ---
    async function fetchTfLRoadDisruptions() {
      const url = `https://api.tfl.gov.uk/Road/All/Disruption?app_key=${TFL_KEY}`;
      let allTfLDisruptions = [];
      let tflTrafficIncidents = [];
      let tflRoadworksIncidents = [];

      try {
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error(`TfL Road Disruption API responded with status: ${resp.status} ${resp.statusText}`);
        }
        const data = await resp.json();
        allTfLDisruptions = data.roadDisruptions || [];

        allTfLDisruptions.forEach(incident => {
          if (incident.point && !isNaN(parseFloat(incident.point.split(',')[0])) && !isNaN(parseFloat(incident.point.split(',')[1]))) {
            const [lat, lon] = incident.point.split(',').map(Number);
            if (isWithinBbox(lat, lon)) {
              const isRoadwork = incident.category?.toLowerCase().includes('roadworks') || incident.category?.toLowerCase().includes('plannedworks') || incident.category?.toLowerCase().includes('works');

              if (isRoadwork) {
                tflRoadworksIncidents.push(incident);
              } else {
                tflTrafficIncidents.push(incident);
              }
            }
          }
        });
        
        return { tflTrafficIncidents, tflRoadworksIncidents };
      } catch (error) {
        console.error("Error fetching TfL road disruptions data:", error);
        document.getElementById("tfl-traffic-incidents").textContent = "Error loading TfL traffic incidents.";
        document.getElementById("tfl-roadworks-incidents").textContent = "Error loading TfL roadworks.";
        return { tflTrafficIncidents: [], tflRoadworksIncidents: [] };
      }
    }

    function renderTfLTraffic(list) {
        const container = document.getElementById("tfl-traffic-incidents");
        container.innerHTML = "";
        if (!list.length) {
            return container.innerHTML = "<p>No TfL traffic incidents reported for SE London.</p>";
        }

        const severityOrder = { "Serious": 1, "Major": 2, "Minor": 3, "Moderate": 4, "Normal": 5, "Good": 6 };
        list.sort((a, b) => {
            const aSev = severityOrder[a.severity] || 99;
            const bSev = severityOrder[b.severity] || 99;
            return aSev - bSev;
        });

        list.forEach(incident => {
            const description = incident.comments || incident.location || "No description available";
            const currentStatus = incident.currentStatus || "Status unknown";
            const category = incident.category || "Incident";
            const roadNames = incident.roadName || "Unnamed road";

            let sevClass = "low"; 
            let emoji = "üîµ"; 
            if (incident.severity === "Serious") {
                sevClass = "high";
                emoji = "üö®";
            } else if (incident.severity === "Major" || incident.severity === "Minor") {
                sevClass = "medium";
                emoji = "üî∂";
            }

            const d = document.createElement("div");
            d.className = `item tfl-item ${sevClass}`; 
            d.innerHTML = `
                <strong>${emoji} ${roadNames}</strong> ‚Äì 
                <em>${category} (${currentStatus})</em><br>
                ${description}
                <br><small>Severity: ${incident.severity || 'Unknown'}</small>
            `;
            container.appendChild(d);
        });
    }

    function renderTfLRoadworks(list) {
        const container = document.getElementById("tfl-roadworks-incidents");
        container.innerHTML = "";
        if (!list.length) {
            return container.innerHTML = "<p>No TfL roadworks reported for SE London.</p>";
        }

        const severityOrder = { "Serious": 1, "Major": 2, "Minor": 3, "Moderate": 4, "Normal": 5, "Good": 6 };
        list.sort((a, b) => {
            const aSev = severityOrder[a.severity] || 99;
            const bSev = severityOrder[b.severity] || 99;
            return aSev - bSev;
        });

        list.forEach(incident => {
            const description = incident.comments || incident.location || "No description available";
            const currentStatus = incident.currentStatus || "Status unknown";
            const roadNames = incident.roadName || "Unnamed road";
            let emoji = "üöß"; 

            let sevClass = "low"; 
            if (incident.severity === "Serious") {
                sevClass = "high";
            } else if (incident.severity === "Major" || incident.severity === "Minor") {
                sevClass = "medium";
            }

            const d = document.createElement("div");
            d.className = `item tfl-item tfl-roadwork-item ${sevClass}`; 
            d.innerHTML = `
                <strong>${emoji} ${roadNames}</strong> ‚Äì 
                <em>Roadwork (${currentStatus})</em><br>
                ${description}
                <br><small>Severity: ${incident.severity || 'Unknown'}</small>
            `;
            container.appendChild(d);
        });
    }

    // --- TfL Public Transport Functions ---
    async function fetchTfLStatus(lines) {
      const url = `https://api.tfl.gov.uk/Line/${lines}/Status?app_key=${TFL_KEY}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`TfL API error: ${res.status} ${res.statusText}`);
      return await res.json();
    }

    async function fetchAndRenderTubeStatus() {
      const container = document.getElementById("tube-status");
      container.innerHTML = ''; 
      try {
        const url = `https://api.tfl.gov.uk/Line/Mode/tube/Status?app_key=${TFL_KEY}`;
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`TfL API error: ${res.status} ${res.statusText}`);
        }
        const data = await res.json();

        if (!Array.isArray(data) || data.length === 0) {
          container.textContent = "No Tube status data available.";
          return;
        }

        data.sort((a, b) => {
          const aSeverity = a.lineStatuses?.[0]?.statusSeverity;
          const bSeverity = b.lineStatuses?.[0]?.statusSeverity;

          const aHasIssue = aSeverity !== 10; 
          const bHasIssue = bSeverity !== 10;

          if (aHasIssue && !bHasIssue) return -1; 
          if (!aHasIssue && bHasIssue) return 1;  

          if (aHasIssue && bHasIssue) {
            return aSeverity - bSeverity;
          } else { 
            return a.name.localeCompare(b.name);
          }
        });

        data.forEach(line => {
          const name = line.name || "Unknown line";
          const statusObj = line.lineStatuses?.[0];
          const status = statusObj?.statusSeverityDescription || "Status unknown";
          const reason = statusObj?.reason || "";
          const severity = statusObj?.statusSeverity;

          let sevClass = "low"; 
          let emoji = "üü¢"; 

          if (severity !== undefined) {
            if (severity === 10) { 
              sevClass = "low";
              emoji = "üü¢";
            } else if (severity === 0) { 
              sevClass = "high";
              emoji = "üî¥";
            } else { 
              sevClass = "medium";
              emoji = "üü†";
            }
          }
          
          const d = document.createElement("div");
          d.className = `item ${sevClass} tube-line-item`; 
          d.innerHTML = `
            <strong>${emoji} ${name}:</strong> ${status}${reason ? " ‚Äì " + reason : ""}
          `;
          container.appendChild(d);
        });

      } catch (err) {
        container.textContent = "Error fetching Tube status: " + err.message;
        console.error(err);
      }
    }

    async function fetchAndRenderOtherStatus(containerId, lines, label) {
      const container = document.getElementById(containerId);
      try {
        const data = await fetchTfLStatus(lines);
        if (!Array.isArray(data) || data.length === 0) {
          container.textContent = `No ${label} status data available.`;
          return;
        }

        const messages = data.map(line => {
          const name = line.name || label;
          const status = line.lineStatuses?.[0]?.statusSeverityDescription || "Unknown";
          const reason = line.lineStatuses?.[0]?.reason || "";
          const severity = line.lineStatuses?.[0]?.statusSeverity;
          let emoji = "üöâ"; 

          if (severity !== undefined) {
             if (severity === 0) { 
               emoji = "üî¥";
             } else if (severity !== 10) { 
               emoji = "üü†";
             }
          }

          return `${emoji} ${name}: ${status}${reason ? " ‚Äì " + reason : ""}`;
        });

        container.innerHTML = "<ul>" + messages.map(m => `<li>${m}</li>`).join("") + "</ul>";
      } catch (err) {
        container.textContent = `Error fetching ${label} status: ` + err.message;
        console.error(err);
      }
    }

    // --- National Rail Functions ---
    async function fetchNationalRailDelays() {
        const container = document.getElementById("national-rail-delays");
        if (NATIONAL_RAIL_API_PROXY_URL === "YOUR_NATIONAL_RAIL_API_PROXY_URL") {
            container.textContent = "National Rail data requires a backend proxy URL to be configured.";
            console.warn("NATIONAL_RAIL_API_PROXY_URL is not set. Please configure your backend proxy URL.");
            return [];
        }

        try {
            // Pass stations and TOC codes to your backend proxy
            // Your proxy will use these to query Darwin and filter results.
            const params = new URLSearchParams({
                stations: SE_LONDON_RAIL_STATIONS.join(','),
                tocs: TARGET_TOC_CODES.join(',') // Sending the desired TOCs to the proxy
            });
            const url = `${NATIONAL_RAIL_API_PROXY_URL}?${params.toString()}`;
            
            const resp = await fetch(url);
            if (!resp.ok) {
                const errorBody = await resp.text();
                throw new Error(`National Rail Proxy error: ${resp.status} ${resp.statusText}. Response: ${errorBody}`);
            }
            const data = await resp.json();
            // Assuming your proxy returns a JSON array of delayed services
            // that are already filtered by the requested stations AND TOCs.
            return data; 
        } catch (error) {
            console.error("Error fetching National Rail data:", error);
            container.textContent = "Error loading National Rail delays.";
            return [];
        }
    }

    function renderNationalRailDelays(list) {
        const container = document.getElementById("national-rail-delays");
        container.innerHTML = ""; 

        if (!list.length) {
            container.innerHTML = "<p>No significant Southeastern or Thameslink delays reported for selected stations.</p>";
            return;
        }

        list.sort((a, b) => {
            if (a.status === "Cancelled" && b.status !== "Cancelled") return -1;
            if (a.status !== "Cancelled" && b.status === "Cancelled") return 1;
            return (a.expected || a.scheduled).localeCompare(b.expected || b.scheduled); 
        });

        list.forEach(delay => {
            let sevClass = "low";
            let emoji = "‚úÖ"; 
            if (delay.status === "Cancelled") {
                sevClass = "high";
                emoji = "‚ùå";
            } else if (delay.status === "Delayed") {
                sevClass = "medium";
                emoji = "‚ö†Ô∏è";
            }

            const d = document.createElement("div");
            d.className = `item ${sevClass}`; 
            d.innerHTML = `
            <strong>${emoji} ${delay.station} to ${delay.destination}</strong><br>
            Scheduled: ${delay.scheduled}, Expected: ${delay.expected} (Platform: ${delay.platform || 'TBC'})<br>
            Status: <em>${delay.status}</em>${delay.delayReason ? ' - ' + delay.delayReason : ''}
            `;
            container.appendChild(d);
        });
    }

    // --- Main Update Functions ---
    async function updateTraffic() {
      // TomTom Traffic
      const tomtomIncidents = await fetchTraffic();
      renderTraffic(tomtomIncidents);
      renderRoadworksToday(tomtomIncidents); // Roadworks still from TomTom

      // TfL Road Disruptions (now categorized)
      const { tflTrafficIncidents, tflRoadworksIncidents } = await fetchTfLRoadDisruptions();
      renderTfLTraffic(tflTrafficIncidents);
      renderTfLRoadworks(tflRoadworksIncidents); // Render TfL specific roadworks

      setTimeout(updateTraffic, REFRESH_INTERVAL_MS);
    }
    
    async function updateTfL() { 
      await fetchAndRenderTubeStatus();
      await fetchAndRenderOtherStatus("river", "rb1,rb6", "River Bus");
      await fetchAndRenderOtherStatus("ferry", "woolwich-ferry", "Woolwich Ferry");
      setTimeout(updateTfL, REFRESH_INTERVAL_MS);
    }

    async function updateWeatherForecast() {
        const weatherData = await fetchWeather();
        renderWeather(weatherData);
        setTimeout(updateWeatherForecast, WEATHER_REFRESH_INTERVAL_MS);
    }

    async function updateNationalRail() {
        const railDelays = await fetchNationalRailDelays();
        renderNationalRailDelays(railDelays);
        setTimeout(updateNationalRail, RAIL_REFRESH_INTERVAL_MS);
    }

    // Initial calls for all data
    updateWeatherForecast();
    updateTraffic();
    updateTfL();
    updateNationalRail(); // Start fetching National Rail data
  </script>
</body>
</html>
