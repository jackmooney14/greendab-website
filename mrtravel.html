<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SE London Presenter Dashboard</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2em;
      max-width: 900px;
      margin: auto;
      background: #fafafa;
    }
    h1, h2 { text-align: center; }
    .section { margin-bottom: 2em; }
    .item { background: white; padding: 1em; margin-bottom: .8em; border-left: 6px solid; border-radius: 5px; }
    /* Existing severity colors */
    .high { border-color: #e53935; } /* Red */
    .medium { border-color: #fb8c00; } /* Orange */
    .low { border-color: #43a047; } /* Green */

    /* New style for tube lines to ensure consistent spacing */
    .tube-line-item {
        display: flex;
        align-items: center; /* Vertically center content */
    }
    .tube-line-item strong {
        margin-right: 0.5em;
    }
    /* Style for TfL traffic - can be merged with .item if desired */
    .tfl-traffic-item {
      background: white;
      padding: 1em;
      margin-bottom: .8em;
      border-left: 6px solid;
      border-radius: 5px;
      border-color: #001a57; /* A custom color for TfL traffic, or use existing severity colors */
    }
    .tfl-traffic-item.high { border-color: #e53935; }
    .tfl-traffic-item.medium { border-color: #fb8c00; }
    .tfl-traffic-item.low { border-color: #43a047; } /* Should be rare for disruptions */
  </style>
</head>
<body>
  <h1>SE London Presenter Dashboard</h1>

  <div class="section" id="traffic">
    <h2>ðŸš¦ Traffic Hotspots (All Incidents)</h2>
    <div id="incidents">Loading TomTom trafficâ€¦</div>
    <div id="tfl-traffic-incidents" style="margin-top: 1.5em;">Loading TfL trafficâ€¦</div>
  </div>

  <div class="section" id="roadworks-today">
    <h2>ðŸ›  Today's Roadworks</h2>
    <div id="roadworks">Loading roadworksâ€¦</div>
  </div>

  <div class="section" id="transport">
    <h2>ðŸš‡ Public Transport Status</h2>
    <div>
      <h3>Tube Status</h3>
      <div id="tube-status">Loading Tube statusâ€¦</div>
    </div>
    <div>
      <h3>River Bus</h3>
      <div id="river">Loading River Busâ€¦</div>
    </div>
    <div>
      <h3>Woolwich Ferry</h3>
      <div id="ferry">Loading Woolwich Ferryâ€¦</div>
    </div>
  </div>

  <script>
    const TOMTOM_KEY = "ZKntlBjAvEOBSRtfMsEdbo31b6UcmJHJ";
    const TFL_KEY = "044bd54cfdc94f03ba10314d52eb59fe";

    // Refresh interval for all data fetches (5 minutes)
    const REFRESH_INTERVAL_MS = 5 * 60 * 1000;

    // Coordinates for Southeast London (tlLat, tlLon, brLat, brLon)
    const bbox = {
      tlLat: 51.51, tlLon: -0.12,
      brLat: 51.30, brLon: 0.25
    };

    // Helper to check if coordinates are within the SE London bbox
    function isWithinBbox(lat, lon) {
      return lat <= bbox.tlLat && lat >= bbox.brLat &&
             lon >= bbox.tlLon && lon <= bbox.brLon;
    }

    // --- TomTom Traffic Functions (unchanged) ---
    async function fetchTraffic() {
      const url = `https://api.tomtom.com/traffic/services/5/incidentDetails?bbox=${bbox.tlLat},${bbox.tlLon},${bbox.brLat},${bbox.brLon}&fields=roadNumbers,events&language=en-GB&key=${TOMTOM_KEY}`;
      try {
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error(`TomTom API responded with status: ${resp.status} ${resp.statusText}`);
        }
        const data = await resp.json();
        return data.incidents || [];
      } catch (error) {
        console.error("Error fetching TomTom traffic data:", error);
        document.getElementById("incidents").textContent = "Error loading TomTom traffic incidents.";
        document.getElementById("roadworks").textContent = "Error loading TomTom roadworks.";
        return [];
      }
    }

    function isEventToday(event) {
      if (!event || !event.startTime || !event.endTime) return false;
      const now = new Date();
      const start = new Date(event.startTime);
      const end = new Date(event.endTime);
      return start <= now && now <= end && start.toDateString() === now.toDateString();
    }

    function renderTraffic(list) {
      const container = document.getElementById("incidents");
      container.innerHTML = "";
      if (!list.length) return container.innerHTML = "<p>No TomTom traffic incidents reported.</p>";

      list.sort((a, b) => b.severity - a.severity);

      list.forEach(i => {
        const sev = i.severity >= 4 ? "high" : i.severity >= 2 ? "medium" : "low";
        const emoji = sev === "high" ? "ðŸ”´" : sev === "medium" ? "ðŸŸ " : "ðŸŸ¢";

        const type = i.type?.replaceAll("_", " ").toLowerCase() || "incident";
        const roads = i.roadNumbers?.join(", ") || "Unnamed road";
        const desc = i.events?.[0]?.description || "No description available";

        const d = document.createElement("div");
        d.className = `item ${sev}`;
        d.innerHTML = `
          <strong>${emoji} ${roads}</strong> â€“ 
          <em>${type}</em><br>
          ${desc} 
          <br><small>Severity: ${i.severity}</small>
        `;
        container.appendChild(d);
      });
    }

    function renderRoadworksToday(list) {
      const container = document.getElementById("roadworks");
      container.innerHTML = "";
      if (!list.length) {
        container.innerHTML = "<p>No TomTom roadworks reported for today.</p>";
        return;
      }

      const roadworksTypes = ["ROAD_WORK", "CONSTRUCTION", "MAINTENANCE"];
      const todayRoadworks = list.filter(i =>
        roadworksTypes.includes(i.type) &&
        i.events?.some(isEventToday)
      );

      if (!todayRoadworks.length) {
        container.innerHTML = "<p>No TomTom roadworks reported for today.</p>";
        return;
      }

      todayRoadworks.sort((a, b) => b.severity - a.severity);

      todayRoadworks.forEach(i => {
        const sev = i.severity >= 4 ? "high" : i.severity >= 2 ? "medium" : "low";
        const emoji = sev === "high" ? "ðŸ”´" : sev === "medium" ? "ðŸŸ " : "ðŸŸ¢";

        const roads = i.roadNumbers?.join(", ") || "Unnamed road";
        const desc = i.events?.[0]?.description || "No description available";

        const d = document.createElement("div");
        d.className = `item ${sev}`;
        d.innerHTML = `
          <strong>${emoji} ${roads}</strong> â€“ 
          <em>roadwork</em><br>
          ${desc} 
          <br><small>Severity: ${i.severity}</small>
        `;
        container.appendChild(d);
      });
    }

    // --- NEW: TfL Traffic Functions ---
    async function fetchTfLTraffic() {
      const url = `https://api.tfl.gov.uk/Road/All/Disruption?app_key=${TFL_KEY}`;
      try {
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error(`TfL Road Disruption API responded with status: ${resp.status} ${resp.statusText}`);
        }
        // TfL Road Disruption API returns JSON, not XML (despite London Datastore hinting at XML feed)
        const data = await resp.json(); 

        // Filter by bbox for South East London
        const seLondonIncidents = data.roadDisruptions.filter(incident => {
          // Check if point coordinates exist and are valid numbers
          if (incident.point && !isNaN(parseFloat(incident.point.split(',')[0])) && !isNaN(parseFloat(incident.point.split(',')[1]))) {
            const [lat, lon] = incident.point.split(',').map(Number);
            return isWithinBbox(lat, lon);
          }
          return false; // Exclude incidents without valid coordinates
        });
        
        return seLondonIncidents || [];
      } catch (error) {
        console.error("Error fetching TfL traffic data:", error);
        document.getElementById("tfl-traffic-incidents").textContent = "Error loading TfL traffic incidents.";
        return [];
      }
    }

    function renderTfLTraffic(list) {
        const container = document.getElementById("tfl-traffic-incidents");
        container.innerHTML = "";
        if (!list.length) {
            return container.innerHTML = "<p>No TfL traffic incidents reported for SE London.</p>";
        }

        // Sort by severity (e.g., 'Major' first) or a custom ranking
        // TfL 'severity' is often text (e.g., 'Major', 'Minor', 'Serious')
        const severityOrder = { "Serious": 1, "Major": 2, "Minor": 3, "Moderate": 4, "Normal": 5, "Good": 6 };
        list.sort((a, b) => {
            const aSev = severityOrder[a.severity] || 99; // Default to low priority if severity unknown
            const bSev = severityOrder[b.severity] || 99;
            return aSev - bSev;
        });

        list.forEach(incident => {
            const description = incident.comments || incident.location || "No description available";
            const currentStatus = incident.currentStatus || "Status unknown";
            const category = incident.category || "Incident";
            const roadNames = incident.roadName || "Unnamed road";

            let sevClass = "low"; // Default
            let emoji = "ðŸ”µ"; // Default for TfL, or specific based on severity
            if (incident.severity === "Serious") {
                sevClass = "high";
                emoji = "ðŸš¨";
            } else if (incident.severity === "Major" || incident.severity === "Minor") {
                sevClass = "medium";
                emoji = "ðŸ”¶";
            }

            const d = document.createElement("div");
            d.className = `item tfl-traffic-item ${sevClass}`; // Use tfl-traffic-item class
            d.innerHTML = `
                <strong>${emoji} ${roadNames}</strong> â€“ 
                <em>${category} (${currentStatus})</em><br>
                ${description}
                <br><small>Severity: ${incident.severity || 'Unknown'}</small>
            `;
            container.appendChild(d);
        });
    }

    // --- Unified Traffic Update ---
    async function updateTraffic() {
      // TomTom Traffic
      const tomtomIncidents = await fetchTraffic();
      renderTraffic(tomtomIncidents);
      renderRoadworksToday(tomtomIncidents); // Roadworks still from TomTom

      // TfL Traffic
      const tflIncidents = await fetchTfLTraffic();
      renderTfLTraffic(tflIncidents);

      setTimeout(updateTraffic, REFRESH_INTERVAL_MS);
    }
    updateTraffic(); // Initial call to update all traffic data

    // --- TfL Public Transport Functions (unchanged, except for tube info formatting) ---
    async function fetchTfLStatus(lines) {
      const url = `https://api.tfl.gov.uk/Line/${lines}/Status?app_key=${TFL_KEY}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`TfL API error: ${res.status} ${res.statusText}`);
      return await res.json();
    }

    async function fetchAndRenderTubeStatus() {
      const container = document.getElementById("tube-status");
      container.innerHTML = ''; 
      try {
        const url = `https://api.tfl.gov.uk/Line/Mode/tube/Status?app_key=${TFL_KEY}`;
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`TfL API error: ${res.status} ${res.statusText}`);
        }
        const data = await res.json();

        if (!Array.isArray(data) || data.length === 0) {
          container.textContent = "No Tube status data available.";
          return;
        }

        data.sort((a, b) => {
          const aSeverity = a.lineStatuses?.[0]?.statusSeverity;
          const bSeverity = b.lineStatuses?.[0]?.statusSeverity;

          const aHasIssue = aSeverity !== 10; 
          const bHasIssue = bSeverity !== 10;

          if (aHasIssue && !bHasIssue) return -1; 
          if (!aHasIssue && bHasIssue) return 1;  

          if (aHasIssue && bHasIssue) {
            return aSeverity - bSeverity;
          } else { 
            return a.name.localeCompare(b.name);
          }
        });

        data.forEach(line => {
          const name = line.name || "Unknown line";
          const statusObj = line.lineStatuses?.[0];
          const status = statusObj?.statusSeverityDescription || "Status unknown";
          const reason = statusObj?.reason || "";
          const severity = statusObj?.statusSeverity;

          let sevClass = "low"; 
          let emoji = "ðŸŸ¢"; 

          if (severity !== undefined) {
            if (severity === 10) { 
              sevClass = "low";
              emoji = "ðŸŸ¢";
            } else if (severity === 0) { 
              sevClass = "high";
              emoji = "ðŸ”´";
            } else { 
              sevClass = "medium";
              emoji = "ðŸŸ ";
            }
          }
          
          const d = document.createElement("div");
          d.className = `item ${sevClass} tube-line-item`; 
          d.innerHTML = `
            <strong>${emoji} ${name}:</strong> ${status}${reason ? " â€“ " + reason : ""}
          `;
          container.appendChild(d);
        });

      } catch (err) {
        container.textContent = "Error fetching Tube status: " + err.message;
        console.error(err);
      }
    }

    async function fetchAndRenderOtherStatus(containerId, lines, label) {
      const container = document.getElementById(containerId);
      try {
        const data = await fetchTfLStatus(lines);
        if (!Array.isArray(data) || data.length === 0) {
          container.textContent = `No ${label} status data available.`;
          return;
        }

        const messages = data.map(line => {
          const name = line.name || label;
          const status = line.lineStatuses?.[0]?.statusSeverityDescription || "Unknown";
          const reason = line.lineStatuses?.[0]?.reason || "";
          const severity = line.lineStatuses?.[0]?.statusSeverity;
          let emoji = "ðŸš‰"; 

          if (severity !== undefined) {
             if (severity === 0) { 
               emoji = "ðŸ”´";
             } else if (severity !== 10) { 
               emoji = "ðŸŸ ";
             }
          }

          return `${emoji} ${name}: ${status}${reason ? " â€“ " + reason : ""}`;
        });

        container.innerHTML = "<ul>" + messages.map(m => `<li>${m}</li>`).join("") + "</ul>";
      } catch (err) {
        container.textContent = `Error fetching ${label} status: ` + err.message;
        console.error(err);
      }
    }

    async function updateTfL() {
      await fetchAndRenderTubeStatus();
      await fetchAndRenderOtherStatus("river", "rb1,rb6", "River Bus");
      await fetchAndRenderOtherStatus("ferry", "woolwich-ferry", "Woolwich Ferry");
      setTimeout(updateTfL, REFRESH_INTERVAL_MS);
    }
    updateTfL();
  </script>
</body>
</html>
